# client_http.py
# Client code for interacting with the MCP server using HTTP transport
import os
import requests
from google import genai
from google.genai import types
from dotenv import load_dotenv
from rich.console import Console  # Added for rich logging

# Initialize rich console
console = Console()

# Load environment variables
load_dotenv()

# Validate GEMINI_API_KEY
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    raise ValueError("Missing GEMINI_API_KEY in .env file.")

# MCP server configuration for HTTP
MCP_SERVER_URL = "http://localhost:10000"  # Adjust if server is remote
# MCP_SERVER_URL = "https://mcp-server-http.onrender.com"  # Adjust if server is remote

# Initialize Gemini client
try:
    client = genai.Client(api_key=GEMINI_API_KEY)
except ValueError as e:
    raise ValueError(f"Failed to initialize Gemini client: {e}")

def run():
    console.print("[bold green]Starting MCP client for HTTP transport...[/bold green]")
    
    try:
        # List available tools
        response = requests.get(f"{MCP_SERVER_URL}/tools")
        response.raise_for_status()
        mcp_tools = response.json().get("tools", [])
        if not mcp_tools:
            console.print("[yellow]No tools available from the MCP server.[/yellow]")
            return

        # Convert MCP tools to Gemini-compatible format
        tools = [
            types.Tool(
                function_declarations=[
                    {
                        "name": tool["name"],
                        "description": tool["description"],
                        "parameters": {
                            k: v
                            for k, v in tool["inputSchema"].items()
                            if k not in ["additionalProperties", "$schema"]
                        },
                    }
                ]
            )
            for tool in mcp_tools
        ]

        # Define the prompt
        # refund orderid : b923efc2b5f017d0d19b40029abf791d3ce703644e70fdaca159e69304b7578c
        # prompt = (
        #     "What's happening with my transaction with initiator src address "
        #     "ANUVKxeqaec3bf4DVPqLTnG1PT3Fng56wPcE7LXAb46Q"
        # )
        # prompt = (
        #     "What's happening with my transaction with initiator src address "
        #     "a563fbdbf7da414bf28c17eddc7637a32e52afb8bf9c17160675b8712fe372f3"
        # )
        prompt = (
            "What's happening with my transaction with initiator src address "
            "59a2684fa9ea740620f84f4d71c724aad9fa1938e0d417ae3cb7cc0ff20ca003"
        )
        # prompt = (
        #     "What's happening with my transaction with initiator src address "
        #     "ANUVKxeqaec3bf4DVPqLTnG1PT3Fng56wPcE7LXAb46Q"
        # )
        # prompt = (
        #     "What's happening with my transaction with initiator src address "
        #     "7yTemZj69s9FgtBHp4dMxpW9kMSv7dXAwzvQNC7gqX7h"
        # )
        # prompt = (
        #     "What's happening with my transaction with initiator src address "
        #     "0x29f72597ca8a21F9D925AE9527ec5639bAFD5075"
        # )

        # Generate content using Gemini API
        response = client.models.generate_content(
            model="gemini-2.5-pro-exp-03-25",
            contents=prompt,
            config=types.GenerateContentConfig(
                temperature=0,
                tools=tools,
            ),
        )

        # Handle function calls
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.function_call:
                    function_call = part.function_call
                    console.print(f"[cyan]Calling tool: {function_call.name}[/cyan]")

                    # Call the tool via HTTP
                    tool_response = requests.post(
                        f"{MCP_SERVER_URL}/tools/{function_call.name}",
                        json={"arguments": dict(function_call.args)}
                    )
                    tool_response.raise_for_status()

                    # Print the result
                    console.print(f"[bold blue]--- Result from {function_call.name} ---[/bold blue]")
                    try:
                        # Server returns text, so print it with newlines interpreted
                        console.print(tool_response.text.replace('\\n', '\n'), markup=False)
                    except Exception as e:
                        console.print("[red]Unexpected result structure from MCP server:[/red]")
                        console.print(tool_response.text.replace('\\n', '\n'), markup=False)
        else:
            console.print("[yellow]No function call was generated by the model.[/yellow]")
            if response.text:
                console.print("[bold]Model response:[/bold]")
                console.print(response.text)
            else:
                console.print("[yellow]No response text available.[/yellow]")
    except Exception as e:
        console.print(f"[red]Error with MCP server: {e}[/red]")

if __name__ == "__main__":
    console.print("[bold green]Starting MCP client...[/bold green]")
    run()
    

# # client_http.py
# # Client code for interacting with the MCP server using HTTP transport
# import os
# import requests
# from google import genai
# from google.genai import types
# from dotenv import load_dotenv

# # Load environment variables
# load_dotenv()

# # Validate GEMINI_API_KEY
# GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
# if not GEMINI_API_KEY:
#     raise ValueError("Missing GEMINI_API_KEY in .env file.")

# # MCP server configuration for HTTP
# MCP_SERVER_URL = "http://localhost:10000"  # Adjust if server is remote
# # MCP_SERVER_URL = "https://mcp-server-http.onrender.com"  # Adjust if server is remote

# # Initialize Gemini client
# try:
#     client = genai.Client(api_key=GEMINI_API_KEY)
# except ValueError as e:
#     raise ValueError(f"Failed to initialize Gemini client: {e}")

# def run():
#     print("Starting MCP client for HTTP transport...")
    
#     try:
#         # List available tools
#         response = requests.get(f"{MCP_SERVER_URL}/tools")
#         response.raise_for_status()
#         mcp_tools = response.json().get("tools", [])
#         if not mcp_tools:
#             print("No tools available from the MCP server.")
#             return

#         # Convert MCP tools to Gemini-compatible format
#         tools = [
#             types.Tool(
#                 function_declarations=[
#                     {
#                         "name": tool["name"],
#                         "description": tool["description"],
#                         "parameters": {
#                             k: v
#                             for k, v in tool["inputSchema"].items()
#                             if k not in ["additionalProperties", "$schema"]
#                         },
#                     }
#                 ]
#             )
#             for tool in mcp_tools
#         ]

#         # Define the prompt
#         # refund orderid : b923efc2b5f017d0d19b40029abf791d3ce703644e70fdaca159e69304b7578c
#         # prompt = (
#         #     "What's happening with my transaction with initiator src address "
#         #     "ANUVKxeqaec3bf4DVPqLTnG1PT3Fng56wPcE7LXAb46Q"
#         # )
#         # prompt = (
#         #     "What's happening with my transaction with initiator src address "
#         #     "ANUVKxeqaec3bf4DVPqLTnG1PT3Fng56wPcE7LXAb46Q"
#         # )
#         prompt = (
#             "What's happening with my transaction with initiator src address "
#             "7yTemZj69s9FgtBHp4dMxpW9kMSv7dXAwzvQNC7gqX7h"
#         )
#         # prompt = (
#         #     "What's happening with my transaction with initiator src address "
#         #     "0x29f72597ca8a21F9D925AE9527ec5639bAFD5075"
#         # )

#         # Generate content using Gemini API
#         response = client.models.generate_content(
#             model="gemini-2.5-pro-exp-03-25",
#             contents=prompt,
#             config=types.GenerateContentConfig(
#                 temperature=0,
#                 tools=tools,
#             ),
#         )

#         # Handle function calls
#         if response.candidates and response.candidates[0].content.parts:
#             for part in response.candidates[0].content.parts:
#                 if part.function_call:
#                     function_call = part.function_call
#                     print(f"Calling tool: {function_call.name}")

#                     # Call the tool via HTTP
#                     tool_response = requests.post(
#                         f"{MCP_SERVER_URL}/tools/{function_call.name}",
#                         json={"arguments": dict(function_call.args)}
#                     )
#                     tool_response.raise_for_status()

#                     # Print the result
#                     print(f"--- Result from {function_call.name} ---")
#                     try:
#                         # Server returns text, so print it directly
#                         print(tool_response.text)
#                     except Exception as e:
#                         print("Unexpected result structure from MCP server:")
#                         print(tool_response.text)
#         else:
#             print("No function call was generated by the model.")
#             if response.text:
#                 print("Model response:")
#                 print(response.text)
#             else:
#                 print("No response text available.")
#     except Exception as e:
#         print(f"Error with MCP server: {e}")

# if __name__ == "__main__":
#     print("Starting MCP client...")
#     run()
